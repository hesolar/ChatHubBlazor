@page "/boardService/{roomId}"
@inject PartidaService partida
@using Server.Data.Services
@using Server.Data.Model
@using BlazorStrap
<h3>BoardService</h3>

<div class="card">
    <BSContainer>

        <h3>Board</h3>

        @foreach( var row in Squares2 ) {
            <BSRow>
                @foreach( Casilla mine in row ) {

                    <button disabled="@mine.isZero" style="width:30px"
                            @oncontextmenu=" (e)=>
            { //right click
            if( !mine.pulsado ) {
            bool b=  logica.Flag(mine.X,mine.Y);
            mine.Flag();}
            }"
                            @onclick="( e ) => LeftClick(mine,e)"
                            @onmousewheel="() =>MouseWheel(mine)"
           >
                        <BSBadge Color="@mine.ColorEstado">  @mine.text  </BSBadge>
                    </button>
                }

            </BSRow>
        }
    </BSContainer>
</div>
    @*Indicadores
        bombs Remaining:   @game.bombsRemaining <br />
        bombs : @game.bombs <br />*@
    flags: @logica.FlagsRemaining


    @code {
        BlazorApp.Server.Data.Model.MinesweeperLogic.MinesweeperLogic logica;
        [Parameter]
        public String roomId { set; get; }
        public List<String> msgs;
        List<List<Casilla>> Squares2;


        protected override void OnInitialized() {
            Partida[] ps = partida.partidas;

            Partida TableroActual = ps.Where(x => x.id == roomId).First();
            logica = TableroActual.logica;
            this.Squares2 = TableroActual.casillas;

        }

        public void LeftClick(Casilla mine,MouseEventArgs e ) {
            if( e.Button == 0 ) {
                if( !mine.pulsado ) {
                    if( !logica.IsButtonFlagged(mine.X,mine.Y) ) {
                        bool alive = logica.MakeMove(mine.X,mine.Y);

                        int bombs = logica.neighborBombs(mine.X,mine.Y);


                        if( alive ) {
                            int bombsNeighb = logica.neighborBombs(mine.X,mine.Y);
                            mine.MakeMove(bombsNeighb);

                            if( logica.neighborBombs(mine.X,mine.Y).Equals(0) ) {
                                RevealZeroSquaresRecursion(mine);
                            }
                        }
                        //else Lost();
                    }
                }
                else {
                    MouseWheel(mine);
                }
            }
            StateHasChanged();
        }

        public void MouseWheel( Casilla mine ) {
            if( !mine.pulsado ) return;
            Func<Casilla,List<Casilla>> CasillasAdyacentes = (m => {
                List<Casilla> vecinos = Squares2.SelectMany(z => z.Where(t => t.X + 1 == m.X || t.X - 1 == m.X || t.X == m.X)).Intersect(
              Squares2.SelectMany(z => z.Where(t => t.Y + 1 == m.Y || t.Y - 1 == m.Y || t.Y == m.Y))).ToList();
                vecinos.Remove(Squares2.SelectMany(z => z.Where(t => t.X == m.X && t.Y == m.Y)).First());
                return vecinos;
            });

            List<Casilla> flag = CasillasAdyacentes(mine).Where(x => x.flag).ToList();
            List<Casilla> notFlagAndNotOpen = CasillasAdyacentes(mine).Where(x => !x.pulsado && !x.flag).ToList();
            int bombsNeighbor = logica.neighborBombs(mine.X,mine.Y);
            if( flag.Count.Equals(bombsNeighbor) ) {
                notFlagAndNotOpen.ForEach(x => {


                    bombsNeighbor = logica.neighborBombs(x.X,x.Y);
                    if( bombsNeighbor == 0 ) {
                        x.MakeMove(0);
                        RevealZeroSquaresRecursion(x);
                    }
                    else {
                        if( logica.MakeMove(x.X,x.Y) ) x.MakeMove(bombsNeighbor);
                        //else Lost();
                    }
                });

            }
            StateHasChanged();
        }

        public void RevealZeroSquaresRecursion( Casilla mine ) {


            Func<Casilla,List<Casilla>> CasillasAdyacentes = (m => {
                List<Casilla> vecinos = Squares2.SelectMany(z => z.Where(t => t.X + 1 == m.X || t.X - 1 == m.X || t.X == m.X)).Intersect(
              Squares2.SelectMany(z => z.Where(t => t.Y + 1 == m.Y || t.Y - 1 == m.Y || t.Y == m.Y))).ToList();
                vecinos.Remove(Squares2.SelectMany(z => z.Where(t => t.X == m.X && t.Y == m.Y)).First());
                return vecinos;
            });



            List<Casilla> minesNeighbors = CasillasAdyacentes(mine);

            //las no zero las despliego
            var notZeroMines = minesNeighbors.Where(x => !x.flag && logica.neighborBombs(x.X,x.Y) != 0).ToList();
            notZeroMines.ForEach(z => z.MakeMove(logica.neighborBombs(z.X,z.Y)));

            //las casillas con 0
            var ZeroMines = minesNeighbors.Where(z => !z.flag && logica.neighborBombs(z.X,z.Y).Equals(0)).ToList();

            foreach( Casilla m in ZeroMines ) {

                m.MakeMove(0);
                List<Casilla> a = CasillasAdyacentes(m);
                a.AsParallel().ToList().Where(x => !x.flag && logica.neighborBombs(x.X,x.Y) != 0).ToList().ForEach(x => x.MakeMove(logica.neighborBombs(x.X,x.Y)));

                List<Casilla> b = a.Where(x => !x.flag && logica.neighborBombs(x.X,x.Y) == 0 && !x.pulsado).ToList();
                b.AsParallel().ToList().ForEach(x => x.MakeMove(0));
                b.AsParallel().ToList().ForEach(x => RevealZeroSquaresRecursion(x));



            }
        }

    }
